import { writeFileSafe } from "../utils.js";
import path from "path";

export function generateNxWorkspaceSupport(targetRoot, options = {}) {
  const { 
    ts = false, 
    apps = ['api', 'frontend'], 
    libs = ['shared', 'types', 'utils'],
    express = true,
    react = false,
    angular = false,
    next = false
  } = options;
  
  // Nx workspace configuration
  const nxConfig = generateNxConfig(ts);
  writeFileSafe(path.join(targetRoot, "nx.json"), nxConfig);
  
  // Package.json with Nx dependencies
  const packageJson = generateNxPackageJson(ts, apps, libs);
  writeFileSafe(path.join(targetRoot, "package.json"), packageJson);
  
  // Workspace configuration
  const workspaceConfig = generateWorkspaceConfig(ts);
  writeFileSafe(path.join(targetRoot, "workspace.json"), workspaceConfig);
  
  // Generate applications
  apps.forEach(app => {
    generateNxApp(targetRoot, app, ts, express, react, angular, next);
  });
  
  // Generate libraries
  libs.forEach(lib => {
    generateNxLib(targetRoot, lib, ts);
  });
  
  // Nx scripts
  const nxScripts = generateNxScripts(ts);
  writeFileSafe(path.join(targetRoot, "scripts", "nx-scripts.js"), nxScripts);
  
  // Docker configuration for Nx
  const dockerConfig = generateNxDockerConfig(ts);
  writeFileSafe(path.join(targetRoot, "Dockerfile"), dockerConfig);
  
  // Docker compose for development
  const dockerCompose = generateNxDockerCompose(ts);
  writeFileSafe(path.join(targetRoot, "docker-compose.yml"), dockerCompose);
  
  console.log(`🏗️ Nx workspace with ${apps.length} apps and ${libs.length} libs created successfully!`);
}

function generateNxConfig(ts) {
  return JSON.stringify({
    "version": 2,
    "namedInputs": {
      "default": ["{projectRoot}/**/*", "sharedGlobals"],
      "production": [
        "default",
        "!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?",
        "!{projectRoot}/tsconfig.spec.json",
        "!{projectRoot}/jest.config.[jt]s",
        "!{projectRoot}/src/test-setup.[jt]s",
        "!{projectRoot}/test-setup.[jt]s",
        "!{projectRoot}/.eslintrc.json",
        "!{projectRoot}/eslint.config.js"
      ],
      "sharedGlobals": []
    },
    "targetDefaults": {
      "build": {
        "dependsOn": ["^build"],
        "inputs": ["production", "^production"],
        "cache": true
      },
      "test": {
        "inputs": ["default", "^production", "{workspaceRoot}/jest.preset.js"],
        "cache": true
      },
      "lint": {
        "inputs": ["default", "{workspaceRoot}/.eslintrc.json"],
        "cache": true
      },
      "serve": {
        "cache": false
      }
    },
    "generators": {
      "@nx/express": {
        "application": {
          "style": "css",
          "linter": "eslint",
          "bundler": "webpack"
        }
      }
    },
    "defaultProject": "api"
  }, null, 2);
}

function generateNxPackageJson(ts, apps, libs) {
  const dependencies = {
    "@nx/express": "^18.0.0",
    "@nx/node": "^18.0.0",
    "@nx/workspace": "^18.0.0",
    "@nx/jest": "^18.0.0",
    "@nx/eslint-plugin": "^18.0.0",
    "nx": "^18.0.0"
  };
  
  if (ts) {
    dependencies["typescript"] = "^5.0.0";
    dependencies["@types/node"] = "^20.0.0";
  }
  
  return JSON.stringify({
    "name": "fiexpress-nx-workspace",
    "version": "1.0.0",
    "description": "Nx workspace generated by FiExpress",
    "private": true,
    "scripts": {
      "build": "nx build",
      "test": "nx test",
      "lint": "nx lint",
      "serve": "nx serve",
      "serve:api": "nx serve api",
      "serve:frontend": "nx serve frontend",
      "build:all": "nx run-many --target=build --all",
      "test:all": "nx run-many --target=test --all",
      "lint:all": "nx run-many --target=lint --all",
      "affected:build": "nx affected --target=build",
      "affected:test": "nx affected --target=test",
      "affected:lint": "nx affected --target=lint",
      "graph": "nx graph",
      "reset": "nx reset"
    },
    "dependencies": {
      "express": "^4.18.0",
      "cors": "^2.8.5",
      "helmet": "^7.0.0",
      "dotenv": "^16.0.0"
    },
    "devDependencies": dependencies,
    "engines": {
      "node": ">=18.0.0"
    }
  }, null, 2);
}

function generateWorkspaceConfig(ts) {
  return JSON.stringify({
    "version": 2,
    "projects": {
      "api": {
        "root": "apps/api",
        "sourceRoot": "apps/api/src",
        "projectType": "application",
        "targets": {
          "build": {
            "executor": "@nx/webpack:webpack",
            "outputs": ["{options.outputPath}"],
            "options": {
              "target": "node",
              "compiler": "tsc",
              "outputPath": "dist/apps/api",
              "main": "apps/api/src/main.ts",
              "tsConfig": "apps/api/tsconfig.app.json",
              "assets": ["apps/api/src/assets"]
            }
          },
          "serve": {
            "executor": "@nx/js:node",
            "options": {
              "buildTarget": "api:build"
            }
          },
          "test": {
            "executor": "@nx/jest:jest",
            "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
            "options": {
              "jestConfig": "apps/api/jest.config.ts",
              "passWithNoTests": true
            }
          },
          "lint": {
            "executor": "@nx/eslint:lint",
            "outputs": ["{options.outputFile}"]
          }
        }
      },
      "frontend": {
        "root": "apps/frontend",
        "sourceRoot": "apps/frontend/src",
        "projectType": "application",
        "targets": {
          "build": {
            "executor": "@nx/webpack:webpack",
            "outputs": ["{options.outputPath}"],
            "options": {
              "target": "web",
              "compiler": "tsc",
              "outputPath": "dist/apps/frontend",
              "main": "apps/frontend/src/main.ts",
              "tsConfig": "apps/frontend/tsconfig.app.json",
              "assets": ["apps/frontend/src/assets"]
            }
          },
          "serve": {
            "executor": "@nx/webpack:dev-server",
            "options": {
              "buildTarget": "frontend:build"
            }
          },
          "test": {
            "executor": "@nx/jest:jest",
            "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
            "options": {
              "jestConfig": "apps/frontend/jest.config.ts",
              "passWithNoTests": true
            }
          },
          "lint": {
            "executor": "@nx/eslint:lint",
            "outputs": ["{options.outputFile}"]
          }
        }
      }
    }
  }, null, 2);
}

function generateNxApp(targetRoot, appName, ts, express, react, angular, next) {
  const appDir = path.join(targetRoot, "apps", appName);
  
  // App package.json
  const appPackageJson = generateAppPackageJson(appName, ts);
  writeFileSafe(path.join(appDir, "package.json"), appPackageJson);
  
  // App configuration
  const appConfig = generateAppConfig(appName, ts, express, react, angular, next);
  writeFileSafe(path.join(appDir, "project.json"), appConfig);
  
  // TypeScript config
  if (ts) {
    const tsConfig = generateAppTsConfig(appName);
    writeFileSafe(path.join(appDir, "tsconfig.json"), tsConfig);
    writeFileSafe(path.join(appDir, "tsconfig.app.json"), tsConfig);
  }
  
  // Jest config
  const jestConfig = generateAppJestConfig(appName, ts);
  writeFileSafe(path.join(appDir, "jest.config.js"), jestConfig);
  
  // ESLint config
  const eslintConfig = generateAppEslintConfig(appName);
  writeFileSafe(path.join(appDir, ".eslintrc.json"), eslintConfig);
  
  // Source files
  if (express) {
    generateExpressApp(targetRoot, appName, ts);
  } else if (react) {
    generateReactApp(targetRoot, appName, ts);
  } else if (angular) {
    generateAngularApp(targetRoot, appName, ts);
  } else if (next) {
    generateNextApp(targetRoot, appName, ts);
  }
}

function generateExpressApp(targetRoot, appName, ts) {
  const appDir = path.join(targetRoot, "apps", appName, "src");
  
  // Main application file
  const mainFile = ts ? generateExpressMainTs() : generateExpressMainJs();
  writeFileSafe(path.join(appDir, ts ? "main.ts" : "main.js"), mainFile);
  
  // App module
  const appModule = ts ? generateExpressAppModuleTs() : generateExpressAppModuleJs();
  writeFileSafe(path.join(appDir, "app.module.ts"), appModule);
  
  // Routes
  const routes = ts ? generateExpressRoutesTs() : generateExpressRoutesJs();
  writeFileSafe(path.join(appDir, "routes", "index.ts"), routes);
  
  // Controllers
  const controller = ts ? generateExpressControllerTs() : generateExpressControllerJs();
  writeFileSafe(path.join(appDir, "controllers", "app.controller.ts"), controller);
  
  // Services
  const service = ts ? generateExpressServiceTs() : generateExpressServiceJs();
  writeFileSafe(path.join(appDir, "services", "app.service.ts"), service);
}

function generateExpressMainTs() {
  return `import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();`;
}

function generateExpressMainJs() {
  return `const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
require('dotenv').config();

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api', require('./routes'));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(\`🚀 Server running on port \${PORT}\`);
});`;
}

function generateNxLib(targetRoot, libName, ts) {
  const libDir = path.join(targetRoot, "libs", libName);
  
  // Library package.json
  const libPackageJson = generateLibPackageJson(libName, ts);
  writeFileSafe(path.join(libDir, "package.json"), libPackageJson);
  
  // Library configuration
  const libConfig = generateLibConfig(libName, ts);
  writeFileSafe(path.join(libDir, "project.json"), libConfig);
  
  // TypeScript config
  if (ts) {
    const tsConfig = generateLibTsConfig(libName);
    writeFileSafe(path.join(libDir, "tsconfig.json"), tsConfig);
    writeFileSafe(path.join(libDir, "tsconfig.lib.json"), tsConfig);
  }
  
  // Jest config
  const jestConfig = generateLibJestConfig(libName, ts);
  writeFileSafe(path.join(libDir, "jest.config.js"), jestConfig);
  
  // ESLint config
  const eslintConfig = generateLibEslintConfig(libName);
  writeFileSafe(path.join(libDir, ".eslintrc.json"), eslintConfig);
  
  // Library source files
  generateLibSource(targetRoot, libName, ts);
}

function generateLibSource(targetRoot, libName, ts) {
  const libDir = path.join(targetRoot, "libs", libName, "src");
  
  // Index file
  const indexFile = ts ? generateLibIndexTs(libName) : generateLibIndexJs(libName);
  writeFileSafe(path.join(libDir, "index.ts"), indexFile);
  
  // Main library file
  const mainFile = ts ? generateLibMainTs(libName) : generateLibMainJs(libName);
  writeFileSafe(path.join(libDir, `lib/${libName}.ts`), mainFile);
  
  // Test file
  const testFile = ts ? generateLibTestTs(libName) : generateLibTestJs(libName);
  writeFileSafe(path.join(libDir, `lib/${libName}.spec.ts`), testFile);
}

function generateNxScripts(ts) {
  return `#!/usr/bin/env node

const { execSync } = require('child_process');
const path = require('path');

const commands = {
  'build:all': 'nx run-many --target=build --all',
  'test:all': 'nx run-many --target=test --all',
  'lint:all': 'nx run-many --target=lint --all',
  'affected:build': 'nx affected --target=build',
  'affected:test': 'nx affected --target=test',
  'affected:lint': 'nx affected --target=lint',
  'graph': 'nx graph',
  'reset': 'nx reset'
};

function runCommand(command) {
  try {
    console.log(\`Running: \${command}\`);
    execSync(command, { stdio: 'inherit', cwd: process.cwd() });
  } catch (error) {
    console.error(\`Error running command: \${command}\`);
    console.error(error.message);
    process.exit(1);
  }
}

const command = process.argv[2];
if (commands[command]) {
  runCommand(commands[command]);
} else {
  console.log('Available commands:');
  Object.keys(commands).forEach(cmd => {
    console.log(\`  \${cmd}\`);
  });
}`;
}

function generateNxDockerConfig(ts) {
  return `# Multi-stage build for Nx workspace
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
WORKDIR /app

# Copy package files
COPY package*.json ./
COPY nx.json ./
COPY workspace.json ./

# Install dependencies
RUN npm ci --only=production

# Build stage
FROM base AS builder
WORKDIR /app

# Copy package files
COPY package*.json ./
COPY nx.json ./
COPY workspace.json ./

# Install all dependencies
RUN npm ci

# Copy source code
COPY . .

# Build all applications
RUN npx nx build --all

# Production stage
FROM base AS runner
WORKDIR /app

# Copy built applications
COPY --from=builder /app/dist ./dist
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./

# Expose port
EXPOSE 3000

# Start the application
CMD ["node", "dist/apps/api/main.js"]`;
}

function generateNxDockerCompose(ts) {
  return `version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - redis
      - postgres

  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: fiexpress
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:`;
}

// Helper functions for generating specific configurations
function generateAppPackageJson(appName, ts) {
  return JSON.stringify({
    "name": `@fiexpress/${appName}`,
    "version": "1.0.0",
    "main": ts ? "main.ts" : "main.js",
    "scripts": {
      "build": "nx build",
      "serve": "nx serve",
      "test": "nx test",
      "lint": "nx lint"
    }
  }, null, 2);
}

function generateAppConfig(appName, ts, express, react, angular, next) {
  const config = {
    "name": appName,
    "root": `apps/${appName}`,
    "sourceRoot": `apps/${appName}/src`,
    "projectType": "application",
    "targets": {
      "build": {
        "executor": "@nx/webpack:webpack",
        "outputs": ["{options.outputPath}"],
        "options": {
          "target": express ? "node" : "web",
          "compiler": "tsc",
          "outputPath": `dist/apps/${appName}`,
          "main": `apps/${appName}/src/main.${ts ? 'ts' : 'js'}`,
          "tsConfig": `apps/${appName}/tsconfig.app.json`,
          "assets": [`apps/${appName}/src/assets`]
        }
      },
      "serve": {
        "executor": express ? "@nx/js:node" : "@nx/webpack:dev-server",
        "options": {
          "buildTarget": `${appName}:build`
        }
      },
      "test": {
        "executor": "@nx/jest:jest",
        "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
        "options": {
          "jestConfig": `apps/${appName}/jest.config.js`,
          "passWithNoTests": true
        }
      },
      "lint": {
        "executor": "@nx/eslint:lint",
        "outputs": ["{options.outputFile}"]
      }
    }
  };
  
  return JSON.stringify(config, null, 2);
}

function generateAppTsConfig(appName) {
  return JSON.stringify({
    "extends": "../../tsconfig.base.json",
    "compilerOptions": {
      "module": "commonjs",
      "outDir": "../../dist/out-tsc",
      "forceConsistentCasingInFileNames": true,
      "strict": true,
      "noImplicitOverride": true,
      "noPropertyAccessFromIndexSignature": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true
    },
    "files": [],
    "include": [],
    "references": [
      {
        "path": "./tsconfig.app.json"
      }
    ]
  }, null, 2);
}

function generateAppJestConfig(appName, ts) {
  return `module.exports = {
  displayName: '${appName}',
  preset: '../../jest.preset.js',
  testEnvironment: 'node',
  transform: {
    '^.+\\\\.ts$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../coverage/apps/${appName}',
};`;
}

function generateAppEslintConfig(appName) {
  return JSON.stringify({
    "extends": ["../../.eslintrc.json"],
    "ignorePatterns": ["!**/*"],
    "overrides": [
      {
        "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
        "rules": {}
      }
    ]
  }, null, 2);
}

function generateLibPackageJson(libName, ts) {
  return JSON.stringify({
    "name": `@fiexpress/${libName}`,
    "version": "1.0.0",
    "main": ts ? "index.ts" : "index.js",
    "scripts": {
      "build": "nx build",
      "test": "nx test",
      "lint": "nx lint"
    }
  }, null, 2);
}

function generateLibConfig(libName, ts) {
  return JSON.stringify({
    "name": libName,
    "root": `libs/${libName}`,
    "sourceRoot": `libs/${libName}/src`,
    "projectType": "library",
    "targets": {
      "build": {
        "executor": "@nx/js:tsc",
        "outputs": ["{options.outputPath}"],
        "options": {
          "outputPath": `dist/libs/${libName}`,
          "main": `libs/${libName}/src/index.ts`,
          "tsConfig": `libs/${libName}/tsconfig.lib.json`,
          "assets": [`libs/${libName}/*.md`]
        }
      },
      "test": {
        "executor": "@nx/jest:jest",
        "outputs": ["{workspaceRoot}/coverage/{projectRoot}"],
        "options": {
          "jestConfig": `libs/${libName}/jest.config.js`,
          "passWithNoTests": true
        }
      },
      "lint": {
        "executor": "@nx/eslint:lint",
        "outputs": ["{options.outputFile}"]
      }
    }
  }, null, 2);
}

function generateLibTsConfig(libName) {
  return JSON.stringify({
    "extends": "../../tsconfig.base.json",
    "compilerOptions": {
      "module": "commonjs",
      "outDir": "../../dist/out-tsc",
      "forceConsistentCasingInFileNames": true,
      "strict": true,
      "noImplicitOverride": true,
      "noPropertyAccessFromIndexSignature": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true
    },
    "files": [],
    "include": [],
    "references": [
      {
        "path": "./tsconfig.lib.json"
      }
    ]
  }, null, 2);
}

function generateLibJestConfig(libName, ts) {
  return `module.exports = {
  displayName: '${libName}',
  preset: '../../jest.preset.js',
  testEnvironment: 'node',
  transform: {
    '^.+\\\\.ts$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../coverage/libs/${libName}',
};`;
}

function generateLibEslintConfig(libName) {
  return JSON.stringify({
    "extends": ["../../.eslintrc.json"],
    "ignorePatterns": ["!**/*"],
    "overrides": [
      {
        "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
        "rules": {}
      }
    ]
  }, null, 2);
}

function generateLibIndexTs(libName) {
  return `export * from './lib/${libName}';`;
}

function generateLibIndexJs(libName) {
  return `module.exports = require('./lib/${libName}');`;
}

function generateLibMainTs(libName) {
  return `export class ${libName.charAt(0).toUpperCase() + libName.slice(1)} {
  constructor() {
    // Initialize ${libName}
  }
  
  public getValue(): string {
    return 'Hello from ${libName}!';
  }
}`;
}

function generateLibMainJs(libName) {
  return `class ${libName.charAt(0).toUpperCase() + libName.slice(1)} {
  constructor() {
    // Initialize ${libName}
  }
  
  getValue() {
    return 'Hello from ${libName}!';
  }
}

module.exports = { ${libName.charAt(0).toUpperCase() + libName.slice(1)} };`;
}

function generateLibTestTs(libName) {
  return `import { ${libName.charAt(0).toUpperCase() + libName.slice(1)} } from './lib/${libName}';

describe('${libName.charAt(0).toUpperCase() + libName.slice(1)}', () => {
  it('should create an instance', () => {
    expect(new ${libName.charAt(0).toUpperCase() + libName.slice(1)}()).toBeDefined();
  });
  
  it('should return a value', () => {
    const instance = new ${libName.charAt(0).toUpperCase() + libName.slice(1)}();
    expect(instance.getValue()).toBe('Hello from ${libName}!');
  });
});`;
}

function generateLibTestJs(libName) {
  return `const { ${libName.charAt(0).toUpperCase() + libName.slice(1)} } = require('./lib/${libName}');

describe('${libName.charAt(0).toUpperCase() + libName.slice(1)}', () => {
  it('should create an instance', () => {
    expect(new ${libName.charAt(0).toUpperCase() + libName.slice(1)}()).toBeDefined();
  });
  
  it('should return a value', () => {
    const instance = new ${libName.charAt(0).toUpperCase() + libName.slice(1)}();
    expect(instance.getValue()).toBe('Hello from ${libName}!');
  });
});`;
}

function generateExpressAppModuleTs() {
  return `import { Module } from '@nestjs/common';
import { AppController } from './controllers/app.controller';
import { AppService } from './services/app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}`;
}

function generateExpressAppModuleJs() {
  return `// Express app module configuration
module.exports = {
  // Module configuration
};`;
}

function generateExpressRoutesTs() {
  return `import { Router } from 'express';
import { AppController } from '../controllers/app.controller';

const router = Router();
const appController = new AppController();

router.get('/', appController.getHello.bind(appController));
router.get('/health', appController.getHealth.bind(appController));

export default router;`;
}

function generateExpressRoutesJs() {
  return `const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  res.json({ message: 'Hello from Express API!' });
});

router.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

module.exports = router;`;
}

function generateExpressControllerTs() {
  return `import { Controller, Get } from '@nestjs/common';
import { AppService } from '../services/app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('health')
  getHealth() {
    return this.appService.getHealth();
  }
}`;
}

function generateExpressControllerJs() {
  return `class AppController {
  constructor(appService) {
    this.appService = appService;
  }

  getHello() {
    return this.appService.getHello();
  }

  getHealth() {
    return this.appService.getHealth();
  }
}

module.exports = { AppController };`;
}

function generateExpressServiceTs() {
  return `import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello from Express API!';
  }

  getHealth() {
    return {
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    };
  }
}`;
}

function generateExpressServiceJs() {
  return `class AppService {
  getHello() {
    return 'Hello from Express API!';
  }

  getHealth() {
    return {
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    };
  }
}

module.exports = { AppService };`;
}

function generateReactApp(targetRoot, appName, ts) {
  // React app generation logic
  console.log(`Generating React app: ${appName}`);
}

function generateAngularApp(targetRoot, appName, ts) {
  // Angular app generation logic
  console.log(`Generating Angular app: ${appName}`);
}

function generateNextApp(targetRoot, appName, ts) {
  // Next.js app generation logic
  console.log(`Generating Next.js app: ${appName}`);
}
