import { writeFileSafe } from "../utils.js";
import path from "path";
import fs from "fs";

export function generateNxWorkspaceSupport(targetRoot, options = {}) {
  const { 
    ts = false, 
    apps = ['api', 'frontend'], 
    libs = ['shared', 'types', 'utils'],
    express = true,
    react = false,
    angular = false,
    next = false
  } = options;
  
  // Nx workspace configuration
  const nxConfig = generateNxConfig(ts);
  writeFileSafe(path.join(targetRoot, "nx.json"), nxConfig);
  
  // Package.json with Nx dependencies
  const packageJson = generateNxPackageJson(ts, apps, libs);
  writeFileSafe(path.join(targetRoot, "package.json"), packageJson);
  
  // Workspace configuration (deprecated, using project.json files instead)
  // const workspaceConfig = generateWorkspaceConfig(ts);
  // writeFileSafe(path.join(targetRoot, "workspace.json"), workspaceConfig);
  
  // Generate applications
  apps.forEach(app => {
    generateNxApp(targetRoot, app, ts, express, react, angular, next);
  });
  
  // Generate libraries
  libs.forEach(lib => {
    generateNxLib(targetRoot, lib, ts);
  });
  
  // Generate ORM support
  generateOrmSupport(targetRoot, ts);
  
  // Generate microservices support if enabled
  if (process.env.FIEXPRESS_MICROSERVICES === "yes") {
    generateMicroservicesSupport(targetRoot, ts);
  }
  
  // Generate Cote support if enabled
  if (process.env.FIEXPRESS_COTE === "yes") {
    generateCoteSupport(targetRoot, ts);
  }
  
  // Nx scripts
  const nxScripts = generateNxScripts(ts);
  writeFileSafe(path.join(targetRoot, "scripts", "nx-scripts.js"), nxScripts);
  
  // TypeScript base configuration
  const tsconfigBase = generateTsconfigBase(ts);
  writeFileSafe(path.join(targetRoot, "tsconfig.base.json"), tsconfigBase);
  
  // Docker configuration for Nx
  const dockerConfig = generateNxDockerConfig(ts);
  writeFileSafe(path.join(targetRoot, "Dockerfile"), dockerConfig);
  
  // Docker compose for development
  const dockerCompose = generateNxDockerCompose(ts);
  writeFileSafe(path.join(targetRoot, "docker-compose.yml"), dockerCompose);
  
  console.log(`ðŸ—ï¸ Nx workspace with ${apps.length} apps and ${libs.length} libs created successfully!`);
}

function generateNxConfig() {
  return JSON.stringify({
    "version": 2,
    "namedInputs": {
      "default": ["{projectRoot}/**/*", "sharedGlobals"],
      "production": [
        "default",
        "!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?",
        "!{projectRoot}/tsconfig.spec.json",
        "!{projectRoot}/jest.config.[jt]s",
        "!{projectRoot}/src/test-setup.[jt]s",
        "!{projectRoot}/test-setup.[jt]s",
        "!{projectRoot}/.eslintrc.json",
        "!{projectRoot}/eslint.config.js"
      ],
      "sharedGlobals": []
    },
    "targetDefaults": {
      "build": {
        "dependsOn": ["^build"],
        "inputs": ["production", "^production"],
        "cache": true
      },
      "test": {
        "inputs": ["default", "^production", "{workspaceRoot}/jest.preset.js"],
        "cache": true
      },
      "lint": {
        "inputs": ["default", "{workspaceRoot}/.eslintrc.json"],
        "cache": true
      },
      "serve": {
        "cache": false
      }
    },
    "generators": {
      "@nx/express": {
        "application": {
          "style": "css",
          "linter": "eslint",
          "bundler": "webpack"
        }
      }
    },
    "defaultProject": "api"
  }, null, 2);
}

function generateNxPackageJson(ts) {
  const dependencies = {
    "@nx/express": "^18.0.0",
    "@nx/node": "^18.0.0",
    "@nx/workspace": "^18.0.0",
    "@nx/jest": "^18.0.0",
    "@nx/eslint-plugin": "^18.0.0",
    "nx": "^18.0.0"
  };
  
  if (ts) {
    dependencies["typescript"] = "^5.0.0";
    dependencies["@types/node"] = "^20.0.0";
  }
  
  // Add ORM dependencies based on environment variables
  const db = process.env.FIEXPRESS_DB || "postgres";
  const orm = process.env.FIEXPRESS_ORM || "auto";
  
  if (db === "postgres" && (orm === "auto" || orm === "prisma")) {
    dependencies["@prisma/client"] = "^5.0.0";
    dependencies["prisma"] = "^5.0.0";
  } else if (db === "postgres" && orm === "sequelize") {
    dependencies["sequelize"] = "^6.0.0";
    dependencies["pg"] = "^8.0.0";
    dependencies["pg-hstore"] = "^2.3.0";
  } else if (db === "mysql" && (orm === "auto" || orm === "sequelize")) {
    dependencies["sequelize"] = "^6.0.0";
    dependencies["mysql2"] = "^3.0.0";
  } else if (db === "mongo" && (orm === "auto" || orm === "mongoose")) {
    dependencies["mongoose"] = "^8.0.0";
  }
  
  return JSON.stringify({
    "name": "fiexpress-nx-workspace",
    "version": "1.0.0",
    "description": "Nx workspace generated by FiExpress",
    "private": true,
    "scripts": {
      "build": "nx build",
      "test": "nx test",
      "lint": "nx lint",
      "serve": "nx serve",
      "serve:api": "nx serve api",
      "serve:frontend": "nx serve frontend",
      "build:all": "nx run-many --target=build --all",
      "test:all": "nx run-many --target=test --all",
      "lint:all": "nx run-many --target=lint --all",
      "affected:build": "nx affected --target=build",
      "affected:test": "nx affected --target=test",
      "affected:lint": "nx affected --target=lint",
      "graph": "nx graph",
      "reset": "nx reset"
    },
  "dependencies": {
    "express": "^4.18.0",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "dotenv": "^16.0.0",
    "@types/express": "^4.17.0",
    "@types/cors": "^2.8.0",
    "@types/node": "^20.0.0"
  },
    "devDependencies": dependencies,
    "engines": {
      "node": ">=18.0.0"
    }
  }, null, 2);
}

// Removed unused function

function generateNxApp(targetRoot, appName, ts) {
  const appDir = path.join(targetRoot, "apps", appName);
  
  // Create basic package.json
  const appPackageJson = {
    "name": `@fiexpress/${appName}`,
    "version": "1.0.0",
    "main": ts ? "main.ts" : "main.js",
    "scripts": {
      "build": "nx build",
      "serve": "nx serve",
      "test": "nx test"
    }
  };
  writeFileSafe(path.join(appDir, "package.json"), JSON.stringify(appPackageJson, null, 2));
  
  // Create basic project.json
  const appConfig = {
    "name": appName,
    "root": `apps/${appName}`,
    "sourceRoot": `apps/${appName}/src`,
    "projectType": "application",
    "targets": {
      "build": {
        "executor": "@nx/webpack:webpack",
        "outputs": ["{options.outputPath}"],
        "options": {
          "target": "node",
          "compiler": "tsc",
          "outputPath": `dist/apps/${appName}`,
          "main": `apps/${appName}/src/main.${ts ? 'ts' : 'js'}`,
          "tsConfig": `apps/${appName}/tsconfig.app.json`
        }
      },
      "serve": {
        "executor": "@nx/js:node",
        "options": {
          "buildTarget": `${appName}:build`
        }
      }
    }
  };
  writeFileSafe(path.join(appDir, "project.json"), JSON.stringify(appConfig, null, 2));
  
  // Create src directory
  fs.mkdirSync(path.join(appDir, "src"), { recursive: true });
  
  // Create basic main file with imports
  const mainContent = ts ? 
    `import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: '${appName}',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(\`ðŸš€ ${appName} running on port \${PORT}\`);
});` :
    `const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: '${appName}',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(\`ðŸš€ ${appName} running on port \${PORT}\`);
});`;
  writeFileSafe(path.join(appDir, "src", ts ? "main.ts" : "main.js"), mainContent);
}

// Removed unused function

// Removed unused function

// Removed unused function

function generateNxLib(targetRoot, libName, ts) {
  const libDir = path.join(targetRoot, "libs", libName);
  
  // Create basic package.json
  const libPackageJson = {
    "name": `@fiexpress/${libName}`,
    "version": "1.0.0",
    "main": ts ? "index.ts" : "index.js",
    "scripts": {
      "build": "nx build",
      "test": "nx test"
    }
  };
  writeFileSafe(path.join(libDir, "package.json"), JSON.stringify(libPackageJson, null, 2));
  
  // Create basic project.json
  const libConfig = {
    "name": libName,
    "root": `libs/${libName}`,
    "sourceRoot": `libs/${libName}/src`,
    "projectType": "library",
    "targets": {
      "build": {
        "executor": "@nx/js:tsc",
        "outputs": ["{options.outputPath}"],
        "options": {
          "outputPath": `dist/libs/${libName}`,
          "main": `libs/${libName}/src/index.${ts ? 'ts' : 'js'}`,
          "tsConfig": `libs/${libName}/tsconfig.lib.json`
        }
      }
    }
  };
  writeFileSafe(path.join(libDir, "project.json"), JSON.stringify(libConfig, null, 2));
  
  // Create src directory
  fs.mkdirSync(path.join(libDir, "src"), { recursive: true });
  
  // Create basic index file
  const indexContent = ts ? 
    `export * from './lib/${libName}';` :
    `module.exports = require('./lib/${libName}');`;
  writeFileSafe(path.join(libDir, "src", ts ? "index.ts" : "index.js"), indexContent);
}

// Removed unused function

function generateNxScripts() {
  return `#!/usr/bin/env node

const { execSync } = require('child_process');
const path = require('path');

const commands = {
  'build:all': 'nx run-many --target=build --all',
  'test:all': 'nx run-many --target=test --all',
  'lint:all': 'nx run-many --target=lint --all',
  'affected:build': 'nx affected --target=build',
  'affected:test': 'nx affected --target=test',
  'affected:lint': 'nx affected --target=lint',
  'graph': 'nx graph',
  'reset': 'nx reset'
};

function runCommand(command) {
  try {
    console.log(\`Running: \${command}\`);
    execSync(command, { stdio: 'inherit', cwd: process.cwd() });
  } catch (error) {
    console.error(\`Error running command: \${command}\`);
    console.error(error.message);
    process.exit(1);
  }
}

const command = process.argv[2];
if (commands[command]) {
  runCommand(commands[command]);
} else {
  console.log('Available commands:');
  Object.keys(commands).forEach(cmd => {
    console.log(\`  \${cmd}\`);
  });
}`;
}

function generateNxDockerConfig() {
  return `# Multi-stage build for Nx workspace
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
WORKDIR /app

# Copy package files
COPY package*.json ./
COPY nx.json ./
COPY workspace.json ./

# Install dependencies
RUN npm ci --only=production

# Build stage
FROM base AS builder
WORKDIR /app

# Copy package files
COPY package*.json ./
COPY nx.json ./
COPY workspace.json ./

# Install all dependencies
RUN npm ci

# Copy source code
COPY . .

# Build all applications
RUN npx nx build --all

# Production stage
FROM base AS runner
WORKDIR /app

# Copy built applications
COPY --from=builder /app/dist ./dist
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./

# Expose port
EXPOSE 3000

# Start the application
CMD ["node", "dist/apps/api/main.js"]`;
}

function generateNxDockerCompose() {
  return `version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - redis
      - postgres

  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: fiexpress
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:`;
}

function generateTsconfigBase() {
  return JSON.stringify({
    "compileOnSave": false,
    "compilerOptions": {
      "rootDir": ".",
      "sourceMap": true,
      "declaration": false,
      "moduleResolution": "node",
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "importHelpers": true,
      "target": "es2015",
      "module": "esnext",
      "lib": ["es2020", "dom"],
      "skipLibCheck": true,
      "skipDefaultLibCheck": true,
      "baseUrl": ".",
      "paths": {
        "@fiexpress/shared": ["libs/shared/src/index.ts"],
        "@fiexpress/types": ["libs/types/src/index.ts"],
        "@fiexpress/utils": ["libs/utils/src/index.ts"]
      }
    },
    "exclude": ["node_modules", "tmp"]
  }, null, 2);
}

function generateOrmSupport(targetRoot, ts) {
  const db = process.env.FIEXPRESS_DB || "postgres";
  const orm = process.env.FIEXPRESS_ORM || "auto";
  
  // Create database config directory
  const configDir = path.join(targetRoot, "libs", "shared", "src", "config");
  fs.mkdirSync(configDir, { recursive: true });
  
  // Create basic database config with imports
  const dbConfig = ts ? 
    `import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Database configuration
export const databaseConfig = {
  type: '${db}',
  orm: '${orm}',
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '${db === 'postgres' ? '5432' : db === 'mysql' ? '3306' : '27017'}'),
  username: process.env.DB_USERNAME || '${db === 'postgres' ? 'postgres' : db === 'mysql' ? 'root' : 'admin'}',
  password: process.env.DB_PASSWORD || '${db === 'postgres' ? 'postgres' : db === 'mysql' ? 'password' : 'password'}',
  database: process.env.DB_NAME || 'fiexpress'
};

// Database connection
export const connectDatabase = async () => {
  try {
    console.log('Connecting to database...');
    // Add your database connection logic here
    console.log('Database connected successfully!');
  } catch (error) {
    console.error('Database connection failed:', error);
    throw error;
  }
};` :
    `const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Database configuration
const databaseConfig = {
  type: '${db}',
  orm: '${orm}',
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '${db === 'postgres' ? '5432' : db === 'mysql' ? '3306' : '27017'}'),
  username: process.env.DB_USERNAME || '${db === 'postgres' ? 'postgres' : db === 'mysql' ? 'root' : 'admin'}',
  password: process.env.DB_PASSWORD || '${db === 'postgres' ? 'postgres' : db === 'mysql' ? 'password' : 'password'}',
  database: process.env.DB_NAME || 'fiexpress'
};

// Database connection
const connectDatabase = async () => {
  try {
    console.log('Connecting to database...');
    // Add your database connection logic here
    console.log('Database connected successfully!');
  } catch (error) {
    console.error('Database connection failed:', error);
    throw error;
  }
};

module.exports = { databaseConfig, connectDatabase };`;
  
  writeFileSafe(path.join(configDir, ts ? "database.config.ts" : "database.config.js"), dbConfig);
  
  // Create models directory
  const modelsDir = path.join(targetRoot, "libs", "shared", "src", "models");
  fs.mkdirSync(modelsDir, { recursive: true });
  
  // Create basic user model with imports
  const userModel = ts ? 
    `import { databaseConfig } from '../config/database.config';

// User model
export class User {
  id: string;
  email: string;
  name?: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(id: string, email: string, name?: string) {
    this.id = id;
    this.email = email;
    this.name = name;
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  // Basic CRUD operations
  static async findAll() {
    // Add your database query logic here
    return [];
  }

  static async findById(id: string) {
    // Add your database query logic here
    return null;
  }

  static async create(data: any) {
    // Add your database query logic here
    return new User(Date.now().toString(), data.email, data.name);
  }
}` :
    `const { databaseConfig } = require('../config/database.config');

// User model
class User {
  constructor(id, email, name) {
    this.id = id;
    this.email = email;
    this.name = name;
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  // Basic CRUD operations
  static async findAll() {
    // Add your database query logic here
    return [];
  }

  static async findById(id) {
    // Add your database query logic here
    return null;
  }

  static async create(data) {
    // Add your database query logic here
    return new User(Date.now().toString(), data.email, data.name);
  }
}

module.exports = { User };`;
  
  writeFileSafe(path.join(modelsDir, ts ? "user.model.ts" : "user.model.js"), userModel);
  
  // Create Prisma schema if using Prisma
  if (db === "postgres" && (orm === "auto" || orm === "prisma")) {
    const prismaDir = path.join(targetRoot, "prisma");
    fs.mkdirSync(prismaDir, { recursive: true });
    
    const prismaSchema = `// Prisma schema
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`;
    
    writeFileSafe(path.join(prismaDir, "schema.prisma"), prismaSchema);
  }
  
  console.log(`ðŸ—„ï¸ Database support (${db} + ${orm}) added successfully!`);
}

// Simplified ORM support - just create basic files and directories

function generateMicroservicesSupport(targetRoot, ts) {
  const services = process.env.FIEXPRESS_MICROSERVICES_SERVICES ? 
    process.env.FIEXPRESS_MICROSERVICES_SERVICES.split(',') : 
    ['user', 'product', 'order'];
  
  // Create microservice directories and basic files
  services.forEach(service => {
    const serviceDir = path.join(targetRoot, "apps", service + "-service");
    fs.mkdirSync(serviceDir, { recursive: true });
    
    // Create basic package.json
    const packageJson = {
      "name": `@fiexpress/${service}-service`,
      "version": "1.0.0",
      "main": ts ? "main.ts" : "main.js",
      "scripts": {
        "build": "nx build",
        "serve": "nx serve",
        "test": "nx test"
      }
    };
    writeFileSafe(path.join(serviceDir, "package.json"), JSON.stringify(packageJson, null, 2));
    
    // Create basic project.json
    const projectJson = {
      "name": `${service}-service`,
      "root": `apps/${service}-service`,
      "sourceRoot": `apps/${service}-service/src`,
      "projectType": "application",
      "targets": {
        "build": {
          "executor": "@nx/webpack:webpack",
          "outputs": ["{options.outputPath}"],
          "options": {
            "target": "node",
            "compiler": "tsc",
            "outputPath": `dist/apps/${service}-service`,
            "main": `apps/${service}-service/src/main.${ts ? 'ts' : 'js'}`,
            "tsConfig": `apps/${service}-service/tsconfig.app.json`
          }
        },
        "serve": {
          "executor": "@nx/js:node",
          "options": {
            "buildTarget": `${service}-service:build`
          }
        }
      }
    };
    writeFileSafe(path.join(serviceDir, "project.json"), JSON.stringify(projectJson, null, 2));
    
    // Create src directory
    fs.mkdirSync(path.join(serviceDir, "src"), { recursive: true });
    
    // Create basic main file with imports
    const mainContent = ts ? 
      `import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: '${service}',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(\`ðŸš€ ${service} service running on port \${PORT}\`);
});` :
      `const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: '${service}',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(\`ðŸš€ ${service} service running on port \${PORT}\`);
});`;
    writeFileSafe(path.join(serviceDir, "src", ts ? "main.ts" : "main.js"), mainContent);
  });
  
  // Create API Gateway
  const gatewayDir = path.join(targetRoot, "apps", "api-gateway");
  fs.mkdirSync(gatewayDir, { recursive: true });
  
  const gatewayPackageJson = {
    "name": "@fiexpress/api-gateway",
    "version": "1.0.0",
    "main": ts ? "main.ts" : "main.js",
    "scripts": {
      "build": "nx build",
      "serve": "nx serve"
    }
  };
  writeFileSafe(path.join(gatewayDir, "package.json"), JSON.stringify(gatewayPackageJson, null, 2));
  
  // Create API Gateway main file
  const gatewayMainContent = ts ? 
    `import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: 'api-gateway',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(\`ðŸš€ API Gateway running on port \${PORT}\`);
});` :
    `const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: 'api-gateway',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(\`ðŸš€ API Gateway running on port \${PORT}\`);
});`;
  
  // Create src directory for API Gateway
  fs.mkdirSync(path.join(gatewayDir, "src"), { recursive: true });
  writeFileSafe(path.join(gatewayDir, "src", ts ? "main.ts" : "main.js"), gatewayMainContent);
  
  // Create microservices shared library
  const microservicesLibDir = path.join(targetRoot, "libs", "microservices");
  fs.mkdirSync(microservicesLibDir, { recursive: true });
  
  const microservicesPackageJson = {
    "name": "@fiexpress/microservices",
    "version": "1.0.0",
    "main": "index.ts",
    "scripts": {
      "build": "nx build"
    }
  };
  writeFileSafe(path.join(microservicesLibDir, "package.json"), JSON.stringify(microservicesPackageJson, null, 2));
  
  console.log(`ðŸ—ï¸ Microservices support (${services.join(', ')}) added successfully!`);
}

function generateCoteSupport(targetRoot, ts) {
  // Create Cote service discovery
  generateCoteServiceDiscovery(targetRoot, ts);
  
  // Create Cote inter-service communication
  generateCoteCommunication(targetRoot, ts);
  
  // Create Cote shared library
  generateCoteLib(targetRoot, ts);
  
  console.log(`ðŸ”— Cote microservice communication support added successfully!`);
}

function generateCoteServiceDiscovery(targetRoot, ts) {
  const coteDir = path.join(targetRoot, "libs", "shared", "src", "cote");
  fs.mkdirSync(coteDir, { recursive: true });
  
  // Cote service discovery
  const serviceDiscovery = ts ? 
    `import { Requester, Responder } from 'cote';

export class CoteServiceDiscovery {
  private requester: Requester;
  private responder: Responder;

  constructor(serviceName: string, port?: number) {
    this.requester = new Requester({
      name: \`\${serviceName} requester\`,
      key: 'cote',
      port: port || 5000
    });

    this.responder = new Responder({
      name: \`\${serviceName} responder\`,
      key: 'cote',
      port: port || 5000
    });
  }

  public async callService(serviceName: string, method: string, data?: any) {
    return new Promise((resolve, reject) => {
      this.requester.send({
        type: \`\${serviceName}.\${method}\`,
        data: data || {}
      }, (response: any) => {
        if (response.error) {
          reject(new Error(response.error));
        } else {
          resolve(response.result);
        }
      });
    });
  }

  public registerHandler(method: string, handler: (data: any) => any) {
    this.responder.on(method, handler);
  }

  public close() {
    this.requester.close();
    this.responder.close();
  }
}` :
    `const { Requester, Responder } = require('cote');

class CoteServiceDiscovery {
  constructor(serviceName, port) {
    this.requester = new Requester({
      name: \`\${serviceName} requester\`,
      key: 'cote',
      port: port || 5000
    });

    this.responder = new Responder({
      name: \`\${serviceName} responder\`,
      key: 'cote',
      port: port || 5000
    });
  }

  async callService(serviceName, method, data) {
    return new Promise((resolve, reject) => {
      this.requester.send({
        type: \`\${serviceName}.\${method}\`,
        data: data || {}
      }, (response) => {
        if (response.error) {
          reject(new Error(response.error));
        } else {
          resolve(response.result);
        }
      });
    });
  }

  registerHandler(method, handler) {
    this.responder.on(method, handler);
  }

  close() {
    this.requester.close();
    this.responder.close();
  }
}

module.exports = { CoteServiceDiscovery };`;
  
  writeFileSafe(path.join(coteDir, ts ? "service.discovery.ts" : "service.discovery.js"), serviceDiscovery);
}

function generateCoteCommunication(targetRoot, ts) {
  const coteDir = path.join(targetRoot, "libs", "shared", "src", "cote");
  
  // Cote inter-service communication
  const communication = ts ? 
    `import { CoteServiceDiscovery } from './service.discovery';

export class CoteCommunication {
  private serviceDiscovery: CoteServiceDiscovery;

  constructor(serviceName: string, port?: number) {
    this.serviceDiscovery = new CoteServiceDiscovery(serviceName, port);
  }

  public async callService(serviceName: string, method: string, data?: any) {
    try {
      return await this.serviceDiscovery.callService(serviceName, method, data);
    } catch (error) {
      console.error(\`Failed to call service \${serviceName}.\${method}:\`, error);
      throw error;
    }
  }

  public registerHandler(method: string, handler: (data: any) => any) {
    this.serviceDiscovery.registerHandler(method, handler);
  }

  public async broadcast(event: string, data: any) {
    // Broadcast to all services
    const services = ['user', 'product', 'order'];
    const promises = services.map(service => 
      this.callService(service, event, data).catch(error => {
        console.error(\`Failed to broadcast to \${service}:\`, error);
        return null;
      })
    );
    
    return Promise.allSettled(promises);
  }

  public close() {
    this.serviceDiscovery.close();
  }
}` :
    `const { CoteServiceDiscovery } = require('./service.discovery');

class CoteCommunication {
  constructor(serviceName, port) {
    this.serviceDiscovery = new CoteServiceDiscovery(serviceName, port);
  }

  async callService(serviceName, method, data) {
    try {
      return await this.serviceDiscovery.callService(serviceName, method, data);
    } catch (error) {
      console.error(\`Failed to call service \${serviceName}.\${method}:\`, error);
      throw error;
    }
  }

  registerHandler(method, handler) {
    this.serviceDiscovery.registerHandler(method, handler);
  }

  async broadcast(event, data) {
    // Broadcast to all services
    const services = ['user', 'product', 'order'];
    const promises = services.map(service => 
      this.callService(service, event, data).catch(error => {
        console.error(\`Failed to broadcast to \${service}:\`, error);
        return null;
      })
    );
    
    return Promise.allSettled(promises);
  }

  close() {
    this.serviceDiscovery.close();
  }
}

module.exports = { CoteCommunication };`;
  
  writeFileSafe(path.join(coteDir, ts ? "communication.ts" : "communication.js"), communication);
}

function generateCoteLib(targetRoot, ts) {
  const libDir = path.join(targetRoot, "libs", "cote");
  fs.mkdirSync(libDir, { recursive: true });
  
  // Cote library package.json
  const cotePackageJson = {
    "name": "@fiexpress/cote",
    "version": "1.0.0",
    "main": ts ? "index.ts" : "index.js",
    "scripts": {
      "build": "nx build",
      "test": "nx test"
    },
    "dependencies": {
      "cote": "^1.0.0"
    }
  };
  writeFileSafe(path.join(libDir, "package.json"), JSON.stringify(cotePackageJson, null, 2));
  
  // Cote library project.json
  const coteConfig = {
    "name": "cote",
    "root": "libs/cote",
    "sourceRoot": "libs/cote/src",
    "projectType": "library",
    "targets": {
      "build": {
        "executor": "@nx/js:tsc",
        "outputs": ["{options.outputPath}"],
        "options": {
          "outputPath": "dist/libs/cote",
          "main": "libs/cote/src/index.ts",
          "tsConfig": "libs/cote/tsconfig.lib.json"
        }
      }
    }
  };
  writeFileSafe(path.join(libDir, "project.json"), JSON.stringify(coteConfig, null, 2));
  
  // Create src directory
  fs.mkdirSync(path.join(libDir, "src"), { recursive: true });
  
  // Cote library index
  const coteIndex = ts ? 
    `export * from './lib/cote.service';
export * from './lib/cote.communication';` :
    `module.exports = {
  ...require('./lib/cote.service'),
  ...require('./lib/cote.communication')
};`;
  
  writeFileSafe(path.join(libDir, "src", ts ? "index.ts" : "index.js"), coteIndex);
  
  // Cote service
  const coteService = ts ? 
    `import { CoteServiceDiscovery } from '@fiexpress/shared';

export class CoteService {
  private serviceDiscovery: CoteServiceDiscovery;

  constructor(serviceName: string, port?: number) {
    this.serviceDiscovery = new CoteServiceDiscovery(serviceName, port);
  }

  public async start() {
    console.log('Cote service started');
  }

  public async stop() {
    this.serviceDiscovery.close();
    console.log('Cote service stopped');
  }
}` :
    `const { CoteServiceDiscovery } = require('@fiexpress/shared');

class CoteService {
  constructor(serviceName, port) {
    this.serviceDiscovery = new CoteServiceDiscovery(serviceName, port);
  }

  async start() {
    console.log('Cote service started');
  }

  async stop() {
    this.serviceDiscovery.close();
    console.log('Cote service stopped');
  }
}

module.exports = { CoteService };`;
  
  writeFileSafe(path.join(libDir, "src", "lib", ts ? "cote.service.ts" : "cote.service.js"), coteService);
}

// Helper functions for generating specific configurations
// Removed unused function

// Removed unused function

// Removed unused functions

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function

// Removed unused function
